<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这里要写啥我不是很清楚"><title>python核心 - 并发编程 | 那年八月</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">python核心 - 并发编程</h1><a id="logo" href="/.">那年八月</a><p class="description">奔赴一座城，拥抱一个人 →_→</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa myfa fa-home"></i>首页</a><a href="/archives/"><i class="fa myfa fa-archive"></i>归档</a><a href="/about/"><i class="fa myfa fa-user"></i>关于</a><a href="/guestbook/"><i class="fa myfa fa-comments"></i>留言</a><a href="/atom.xml"><i class="fa myfa fa-rss"></i>订阅</a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">python核心 - 并发编程</h1><div class="post-meta">Dec 9, 2015<span> | </span><span class="category"><a href="/categories/python/">python</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2015/12/09/python/concurrent.html" href="/2015/12/09/python/concurrent.html#ds-thread" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork函数"><span class="toc-number">1.</span> <span class="toc-text">fork函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threading"><span class="toc-number">2.</span> <span class="toc-text">threading</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">3.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#subprocess"><span class="toc-number">4.</span> <span class="toc-text">subprocess</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multiprocessing"><span class="toc-number">5.</span> <span class="toc-text">multiprocessing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程间通信"><span class="toc-number">6.</span> <span class="toc-text">进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步I-O"><span class="toc-number">7.</span> <span class="toc-text">异步I/O</span></a></li></ol></div></div><div class="post-content"><p>现在是多核和并发时代，所以不管什么语言都要支持这个特性。并发是看上去同时执行，并行是在多核上同时执行。</p>
<p>我们先解释下线程和进程。简单来说，一个任务就是一个进程（Process）。
在一个进程内部，要同时干多件事，就需要同时运行多个进程内的“子任务”，这些子任务就叫线程（Thread）</p>
<p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，
完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p>
<p>多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。<a id="more"></a></p>
<p>python中实现并发方式有下面几种：</p>
<ol>
<li>多进程模式</li>
<li>多线程模式</li>
<li>多进程+多线程模式</li>
<li>协程模式</li>
</ol>
<h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><p>我们先要讲一下fork()函数，这个函数只在Unix/Linux/Max上有效，在Windows系统上无效。</p>
<p>一般的函数调用都是一次调用一次返回，而这个特殊的fork()函数调用一次返回两次。
子进程永远返回0，而父进程返回子进程ID</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Process (%s) start...'</span> % os.getpid())</span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid==<span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'I am child process (%s) and my parent is %s.'</span> % (os.getpid(), os.getppid()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'I (%s) just created a child process (%s).'</span> % (os.getpid(), pid))</span><br></pre></td></tr></table></figure>
<h3 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h3><p>编写跨平台的并发程序就不能直接使用上面的fork函数了。</p>
<p>Python主要通过标准库中的threading包来实现多线程。并且Python的线程是真正的Posix Thread，而不是模拟出来的线程</p>
<p>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行，如果要同时修改全局共享变量，需要线程锁：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假定这是你的银行存款:</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_it</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># 先存后取，结果应该为0:</span></span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        <span class="comment"># 先要获取锁:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 放心地改吧:</span></span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 改完了一定要释放锁:</span></span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(balance)</span><br></pre></td></tr></table></figure></p>
<p>另外还可以通过OOP方式创建线程，其实就是定义一个类继承thread.Threading类，内部覆盖run()方法即可。</p>
<p>如果要管理多个线程，还可以使用线程池方式：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool <span class="keyword">as</span> ThreadPool</span><br><span class="line"><span class="keyword">import</span> time,random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(str)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(str)</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_result</span><span class="params">(request, result)</span>:</span></span><br><span class="line">    print(<span class="string">"the result is %s %r"</span> % (request.requestID, result))</span><br><span class="line"></span><br><span class="line">data = [random.randint(<span class="number">1</span>,<span class="number">10</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)]</span><br><span class="line"><span class="comment"># Make the Pool of workers</span></span><br><span class="line">pool = ThreadPool(<span class="number">20</span>)</span><br><span class="line"><span class="comment"># Open the urls in their own threads</span></span><br><span class="line"><span class="comment"># and return the results</span></span><br><span class="line">results = pool.map(hello, data)</span><br><span class="line"><span class="comment">#close the pool and wait for the work to finish</span></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure></p>
<p>这里还得提一下Python中的GIL锁（Global Interpreter Lock），在多核机器上面，无论开启多少个线程同时执行，
只可能会占用一个CPU，因为GIL锁是CPython这个解释器定义的。所以多线程程序不要指望能利用多核，不过不用担心，我们可以用多进程方式。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>多线程下我们应该尽量使用局部变量，但是局部变量在函数多次调用的时候，传递起来很麻烦。
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_student</span><span class="params">(name)</span>:</span></span><br><span class="line">    std = Student(name)</span><br><span class="line">    <span class="comment"># std是局部变量，但是每个函数都要用它，因此必须传进去：</span></span><br><span class="line">    do_task_1(std)</span><br><span class="line">    do_task_2(std)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task_1</span><span class="params">(std)</span>:</span></span><br><span class="line">    do_subtask_1(std)</span><br><span class="line">    do_subtask_2(std)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_task_2</span><span class="params">(std)</span>:</span></span><br><span class="line">    do_subtask_2(std)</span><br><span class="line">    do_subtask_2(std)</span><br></pre></td></tr></table></figure></p>
<p>每个函数一层一层调用都这么传参数那还得了？用全局变量？也不行，因为每个线程处理不同的Student对象，不能共享。</p>
<p>最好的方法是用一个全局dict存放所有的Student对象，然后以thread自身作为key获得线程对应的Student对象。
ThreadLocal应运而生，不用查找dict，ThreadLocal帮你自动做这件事：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建全局ThreadLocal对象:</span></span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_student</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取当前线程关联的student:</span></span><br><span class="line">    std = local_school.student</span><br><span class="line">    print(<span class="string">'Hello, %s (in %s)'</span> % (std, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_thread</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 绑定ThreadLocal的student:</span></span><br><span class="line">    local_school.student = name</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target= process_thread, args=(<span class="string">'Alice'</span>,), name=<span class="string">'Thread-A'</span>)</span><br><span class="line">t2 = threading.Thread(target= process_thread, args=(<span class="string">'Bob'</span>,), name=<span class="string">'Thread-B'</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure></p>
<p>全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。
你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，
可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</p>
<p>ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，
这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>
<h3 id="subprocess"><a href="#subprocess" class="headerlink" title="subprocess"></a>subprocess</h3><p>一个进程可以fork一个子进程，并让这个子进程exec另外一个程序。要编写扩平台的多进程程序，就不能直接使用fork。
在Python中，我们通过标准库中的subprocess包来fork一个子进程，并运行一个外部的程序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行基本系统命令</span></span><br><span class="line">ret = subprocess.call(<span class="string">'ls -l'</span>, shell=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静默执行基本系统命令</span></span><br><span class="line">ret = subprocess.call(<span class="string">'rf -f *.java'</span>, shell=<span class="keyword">True</span>,</span><br><span class="line">                      stdout=open(<span class="string">'/dev/null'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令，但是捕捉输出</span></span><br><span class="line">p = subprocess.Popen(<span class="string">'ls -l'</span>, shell=<span class="keyword">True</span>,</span><br><span class="line">                     stdout=subprocess.PIPE)</span><br><span class="line">out = p.stdout.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令，但是发送输入和接受输出</span></span><br><span class="line">p = subprocess.Popen(<span class="string">'wc'</span>, shell=<span class="keyword">True</span>, stdin=subprocess.PIPE,</span><br><span class="line">                     stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">out, err = p.communicate(<span class="string">'.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个子进程，通过管道通信，实现命令"ls -l | wc"</span></span><br><span class="line">p1 = subprocess.Popen(<span class="string">'ls -l'</span>, stdout=subprocess.PIPE)</span><br><span class="line">p2 = subprocess.Popen(<span class="string">'wc'</span>, stdin=p1.stdout, stdout=subprocess.PIPE)</span><br><span class="line">p1.stdout.close()  <span class="comment"># Allow p1 to receive a SIGPIPE if p2 exits.</span></span><br><span class="line">stdout, stderr = p2.communicate()</span><br><span class="line"><span class="keyword">return</span> p2.returncode, stdout, stderr</span><br></pre></td></tr></table></figure>
<p>通过使用subprocess包，我们可以运行外部程序。这极大的拓展了Python的功能。
如果你已经了解了操作系统的某些应用，你可以从Python中直接调用该应用(而不是完全依赖Python)，
并将应用的结果输出给Python，并让Python继续处理。shell的功能(比如利用文本流连接各个应用)，就可以在Python中实现。</p>
<h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p>使用subprocess包来创建子进程，有两个很大的局限性：</p>
<ol>
<li>我们只能让subprocess运行外部的程序，而不是运行一个Python脚本内部编写的函数</li>
<li>进程间只通过管道进行通信</li>
</ol>
<p>以上限制了我们将subprocess包应用到更广泛的多进程任务。
这样的比较实际是不公平的，因为subprocessing本身就是设计成为一个shell，而不是一个多进程管理包。</p>
<p>multiprocessing包是Python中的多进程管理包。它可以利用multiprocessing.Process对象来创建一个进程，
该进程可以运行在Python程序内部编写的函数。该Process对象与Thread对象的用法相同，也有start(), run(), join()的方法。
此外multiprocessing包中也有Lock/Event/Semaphore/Condition类
(这些对象可以像多线程那样，通过参数传递给各个进程)，用以同步进程，其用法与threading包中的同名类一致。
所以，multiprocessing的很大一部份与threading使用同一套API，只不过换到了多进程的情境。</p>
<p>使用multiprocessing的API的时候，有几点需要注意：</p>
<ol>
<li>在UNIX平台上，当某个进程终结之后，该进程需要被其父进程调用wait，否则进程成为僵尸进程(Zombie)。
所以，有必要对每个Process对象调用join()方法 (实际上等同于wait)。对于多线程来说，由于只有一个进程，所以不存在此必要性。</li>
<li>multiprocessing提供了threading包中没有的IPC(比如Pipe和Queue)，效率上更高。应优先考虑Pipe和Queue</li>
<li>多进程应该避免共享资源，比如全局变量或者传递参数</li>
</ol>
<p>下面演示下它的基本用法：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</span><br><span class="line">    print(<span class="string">'Process will start.'</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="comment"># join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</span></span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'Process end.'</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    <span class="comment"># Pool默认的大小时CUP核心数，这个是有意这样设计的</span></span><br><span class="line">    p = Pool()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(<span class="string">'Waiting for all subprocesses done...'</span>)</span><br><span class="line">    <span class="comment"># 对Pool对象调用join()方法会等待所有子进程执行完毕，</span></span><br><span class="line">    <span class="comment"># 调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。</span></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'All subprocesses done.'</span>)</span><br></pre></td></tr></table></figure></p>
<p>对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，
调用close()之后就不能继续添加新的Process了</p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>multiprocessing包中有Pipe类和Queue类来分别支持管道和消息队列这两种IPC机制。</p>
<p>Pipe可以是单向(half-duplex)，也可以是双向(duplex)。mutiprocessing.Pipe(duplex=False)创建单向管道，
一个进程从PIPE一端输入对象，然后被PIPE另一端的进程接收。
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mul</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc1</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    pipe.send(<span class="string">'hello'</span>)</span><br><span class="line">    print(<span class="string">'proc1 rec:'</span>, pipe.recv())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc2</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    print(<span class="string">'proc2 rec:'</span>, pipe.recv())</span><br><span class="line">    pipe.send(<span class="string">'hello, too'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build a pipe</span></span><br><span class="line">pipe = mul.Pipe()</span><br><span class="line"><span class="comment"># Pass an end of the pipe to process 1</span></span><br><span class="line">p1 = mul.Process(target=proc1, args=(pipe[<span class="number">0</span>],))</span><br><span class="line"><span class="comment"># Pass the other end of the pipe to process 2</span></span><br><span class="line">p2 = mul.Process(target=proc2, args=(pipe[<span class="number">1</span>],))</span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line">p1.join()</span><br><span class="line">p2.join()</span><br></pre></td></tr></table></figure></p>
<p>这里的Pipe是双向的。</p>
<p>Pipe对象建立的时候，返回一个含有两个元素的表，每个元素代表Pipe的一端(Connection对象)。
我们对Pipe的某一端调用send()方法来传送对象，在另一端使用recv()来接收。</p>
<p>Queue与Pipe相类似，都是先进先出的结构。但Queue允许多个进程放入，多个进程从队列取出对象。
Queue使用mutiprocessing.Queue(maxsize)创建，maxsize表示队列中可以存放对象的最大数量。
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</span><br><span class="line">        print(<span class="string">'Put %s to queue...'</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        value = q.get(<span class="keyword">True</span>)</span><br><span class="line">        print(<span class="string">'Get %s from queue.'</span> % value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 父进程创建Queue，并传给各个子进程：</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    <span class="comment"># 启动子进程pw，写入:</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment"># 启动子进程pr，读取:</span></span><br><span class="line">    pr.start()</span><br><span class="line">    <span class="comment"># 等待pw结束:</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></table></figure></p>
<p>下面一个程序演示如何使用一个PIPE来获取multiprocessing.Process进程返回值，让人也可以通过Queue来达到同样效果。
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(procnum, send_end)</span>:</span></span><br><span class="line">    <span class="string">'''worker function'''</span></span><br><span class="line">    result = str(procnum) + <span class="string">' represent!'</span></span><br><span class="line">    print(result)</span><br><span class="line">    send_end.send(result)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    jobs = []</span><br><span class="line">    pipe_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="comment"># 单向管道返回的是(接受端，发送端)</span></span><br><span class="line">        recv_end , send_end = multiprocessing.Pipe(<span class="keyword">False</span>)</span><br><span class="line">        p = multiprocessing.Process(target=worker, args=(i, send_end))</span><br><span class="line">        jobs.append(p)</span><br><span class="line">        pipe_list.append(recv_end)</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> proc <span class="keyword">in</span> jobs:</span><br><span class="line">        proc.join()</span><br><span class="line">    result_list = [x.recv() <span class="keyword">for</span> x <span class="keyword">in</span> pipe_list]</span><br><span class="line">    print(result_list)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> pipe_list:</span><br><span class="line">        x.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，
单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。</p>
<p>现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，
就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，
它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），
充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。</p>
<p>对应到Python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。
python语言通过yield关键字来支持协程，而第三方框架gevent则是一个非常优秀的协程框架。我们会在后续讲解这个。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yidao620c.github.io/2015/12/09/python/concurrent.html" data-id="cixyhzgen006zxgr1989hbioz" class="article-share-link">分享到</a><div class="tags"><a href="/tags/python核心/">python核心</a></div><div class="post-nav"><a href="/2015/12/12/python/regexp.html" class="pre">上一篇: python核心 - 正则表达式</a><a href="/2015/12/05/python/metaclass.html" class="next">下一篇: python核心 - 元类</a></div><div data-thread-key="2015/12/09/python/concurrent.html" data-title="python核心 - 并发编程" data-url="http://yidao620c.github.io/2015/12/09/python/concurrent.html" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2015/12/09/python/concurrent.html" data-title="python核心 - 并发编程" data-url="http://yidao620c.github.io/2015/12/09/python/concurrent.html" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yidao620c.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa myfa fa-folder-o"></i>分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/toolkit/">toolkit</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术随笔/">技术随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/朝花夕拾/">朝花夕拾</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法之美/">算法之美</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa myfa fa-star-o"></i>标签</div><div class="tagcloud"><a href="/tags/scrapy/" style="font-size: 15px;">scrapy</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/负载均衡/" style="font-size: 15px;">负载均衡</a> <a href="/tags/笑话/" style="font-size: 15px;">笑话</a> <a href="/tags/love/" style="font-size: 15px;">love</a> <a href="/tags/memcached/" style="font-size: 15px;">memcached</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/mqtt/" style="font-size: 15px;">mqtt</a> <a href="/tags/osgi/" style="font-size: 15px;">osgi</a> <a href="/tags/rabbitmq/" style="font-size: 15px;">rabbitmq</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/octopress/" style="font-size: 15px;">octopress</a> <a href="/tags/servlet/" style="font-size: 15px;">servlet</a> <a href="/tags/django/" style="font-size: 15px;">django</a> <a href="/tags/sitemesh/" style="font-size: 15px;">sitemesh</a> <a href="/tags/SQLAlchemy/" style="font-size: 15px;">SQLAlchemy</a> <a href="/tags/xpath/" style="font-size: 15px;">xpath</a> <a href="/tags/yaml/" style="font-size: 15px;">yaml</a> <a href="/tags/sed/" style="font-size: 15px;">sed</a> <a href="/tags/awk/" style="font-size: 15px;">awk</a> <a href="/tags/python核心/" style="font-size: 15px;">python核心</a> <a href="/tags/jinja2/" style="font-size: 15px;">jinja2</a> <a href="/tags/vagrant/" style="font-size: 15px;">vagrant</a> <a href="/tags/wsgi/" style="font-size: 15px;">wsgi</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/git/" style="font-size: 15px;">git</a></div></div><div class="widget"><div class="widget-title"><i class="fa myfa fa-file-o"></i>最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/07/joke.html">开心一刻</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/22/linux/awk.html">awk命令笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/20/linux/sed.html">sed命令笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/16/toolkit/mysql-ha.html">centos7配置mysql主从复制</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/09/toolkit/gitlab.html">centos7安装gitlab8.9</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/05/python/jinja2.html">jinja2模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/02/python/vagrant.html">Vagrant创建虚拟化开发环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/love.html">临汾印象</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/26/python/pycharm-remote.html">使用PyCharm进行远程开发和调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/30/python/django-deploy.html">CentOS7上使用mod_wsgi部署Django</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa myfa fa-comment-o"></i>最近评论</div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa myfa fa-external-link"></i>友情链接</div><ul></ul><a href="http://www.huxiu.com/index.php" title="虎嗅网" target="_blank">虎嗅网</a><ul></ul><a href="http://www.infoq.com/cn/" title="InfoQ" target="_blank">InfoQ</a><ul></ul><a href="http://blog.jobbole.com/" title="伯乐在线" target="_blank">伯乐在线</a><ul></ul><a href="http://www.cnblogs.com/" title="博客园" target="_blank">博客园</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <span>2015</span><span class="with-love"><i class="fa fa-heart"></i></span>熊能<br/>
由<a rel="nofollow" target="_blank" href="http://hexo.io/" class="footera">Hexo</a>强力驱动 | 主题<a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo" class="footera">maupassant-hexo</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'yidao620c'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>